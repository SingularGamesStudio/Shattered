#pragma kernel ClearCurrentVolume
#pragma kernel CacheVolumesHierarchical
#pragma kernel CacheKernelH
#pragma kernel ComputeCorrectionL
#pragma kernel CacheF0AndResetLambda
#pragma kernel SaveVelPrefix
#pragma kernel ClearVelDelta
#pragma kernel RelaxScatter
#pragma kernel ApplyVelDelta
#pragma kernel Prolongate
#pragma kernel CommitDeformation
#pragma kernel ExternalForces
#pragma kernel RelaxColored

#include "XPBIAtomics.hlsl"
#include "XPBICommon.hlsl"
#include "XPBISPH.hlsl"
#include "XPBIDeformation.hlsl"

#define targetNeighborCount 6

RWStructuredBuffer<float2> _Pos;
RWStructuredBuffer<float2> _Vel;

StructuredBuffer<float> _InvMass;
StructuredBuffer<uint> _Flags;
StructuredBuffer<float> _RestVolume;
StructuredBuffer<int> _ParentIndex;

RWStructuredBuffer<float4> _F;
RWStructuredBuffer<float4> _Fp;

RWStructuredBuffer<uint> _CurrentVolumeBits;
RWStructuredBuffer<float> _KernelH;
RWStructuredBuffer<float4> _L;
RWStructuredBuffer<float4> _F0;
RWStructuredBuffer<float> _Lambda;

RWStructuredBuffer<float2> _SavedVelPrefix;
RWStructuredBuffer<uint> _VelDeltaBits;

StructuredBuffer<int> _DtNeighbors;
StructuredBuffer<int> _DtNeighborCounts;
StructuredBuffer<int> _ColorOrder;
int _ColorStart;
int _ColorCount;

int _DtNeighborCount;

int _Base;
int _ActiveCount;
int _TotalCount;
int _FineCount;
float _Dt;
float _Gravity;
float _Compliance;

static const float EPS = 1e-6;
static const float KERNEL_H_SCALE = 0.7;

static const float STRETCH_EPS = 1e-6;
static const float EIGEN_OFFDIAG_EPS = 1e-5;
static const float INV_DET_EPS = 1e-8;

static const float YOUNGS = 5e4;
static const float POISSON = 0.3;
static const float MU = (YOUNGS / (2.0 * (1.0 + POISSON)));
static const float LAMBDA = ((YOUNGS * POISSON) / ((1.0 + POISSON) * (1.0 - 2.0 * POISSON)));
static const float YIELD_HENCKY = 0.05;
static const float VOL_HENCKY_LIMIT = 0.3;

static bool XPBI_IsFixed(int gi)
{
    return (_Flags[gi] & 1u) != 0u || _InvMass[gi] <= 0.0;
}

static float XPBI_ReadCurrentVolume(int gi)
{
    return asfloat(_CurrentVolumeBits[gi]);
}

static uint XPBI_VelDeltaIndex(int gi, uint comp)
{
    return (uint)(gi * 2) + comp;
}

static void XPBI_AddVelDelta(int gi, float2 dv)
{
    XPBI_AtomicAddFloatBits(_VelDeltaBits, XPBI_VelDeltaIndex(gi, 0u), dv.x);
    XPBI_AtomicAddFloatBits(_VelDeltaBits, XPBI_VelDeltaIndex(gi, 1u), dv.y);
}

static float2 XPBI_ReadVelDelta(int gi)
{
    return float2(
        asfloat(_VelDeltaBits[XPBI_VelDeltaIndex(gi, 0u)]),
        asfloat(_VelDeltaBits[XPBI_VelDeltaIndex(gi, 1u)]));
}

static int XPBI_LocalIndexFromGlobal(int gi) { return gi - _Base; }
static int XPBI_GlobalIndexFromLocal(int li) { return _Base + li; }

static void XPBI_GetNeighbors(int gi, out int nCount, out int n0, out int n1, out int n2, out int n3, out int n4, out int n5)
{
    int li = XPBI_LocalIndexFromGlobal(gi);

    nCount = _DtNeighborCounts[li];
    if (nCount < 0)
        nCount = 0;
    if (nCount > _DtNeighborCount)
        nCount = _DtNeighborCount;
    if (nCount > targetNeighborCount)
        nCount = targetNeighborCount;

    n0 = -1;
    n1 = -1;
    n2 = -1;
    n3 = -1;
    n4 = -1;
    n5 = -1;

    int baseIdx = li * _DtNeighborCount;

    if (nCount > 0)
        n0 = XPBI_GlobalIndexFromLocal(_DtNeighbors[baseIdx + 0]);
    if (nCount > 1)
        n1 = XPBI_GlobalIndexFromLocal(_DtNeighbors[baseIdx + 1]);
    if (nCount > 2)
        n2 = XPBI_GlobalIndexFromLocal(_DtNeighbors[baseIdx + 2]);
    if (nCount > 3)
        n3 = XPBI_GlobalIndexFromLocal(_DtNeighbors[baseIdx + 3]);
    if (nCount > 4)
        n4 = XPBI_GlobalIndexFromLocal(_DtNeighbors[baseIdx + 4]);
    if (nCount > 5)
        n5 = XPBI_GlobalIndexFromLocal(_DtNeighbors[baseIdx + 5]);
}

[numthreads(256, 1, 1)] void ExternalForces(uint3 id : SV_DispatchThreadID)
{
    int li = (int)id.x;
    if (li >= _TotalCount)
        return;

    int gi = _Base + li;
    if (XPBI_IsFixed(gi))
        return;

    float2 v = _Vel[gi];
    v.y += _Gravity * _Dt;
    _Vel[gi] = v;
}

    [numthreads(256, 1, 1)] void ClearCurrentVolume(uint3 id : SV_DispatchThreadID)
{
    int li = (int)id.x;
    if (li >= _ActiveCount)
        return;
    _CurrentVolumeBits[_Base + li] = 0u;
}

[numthreads(256, 1, 1)] void CacheVolumesHierarchical(uint3 id : SV_DispatchThreadID)
{
    int li = (int)id.x;
    if (li >= _TotalCount)
        return;

    int gi = _Base + li;

    float restV = _RestVolume[gi];
    if (restV <= EPS)
        return;

    XPBI_Mat2 F = XPBI_Mat2FromFloat4(_F[gi]);
    float detF = XPBI_DetMat2(F);
    float leafVol = restV * abs(detF);
    if (leafVol <= EPS)
        return;

    int owner = li;
    [loop] for (int it = 0; it < 64; it++)
    {
        if (owner < 0)
            return;
        if (owner < _ActiveCount)
            break;

        int p = _ParentIndex[_Base + owner];
        if (p < 0)
            return;
        owner = p - _Base;
    }

    if (owner < 0 || owner >= _ActiveCount)
        return;

    XPBI_AtomicAddFloatBits(_CurrentVolumeBits, (uint)(_Base + owner), leafVol);
}

    [numthreads(256, 1, 1)] void CacheKernelH(uint3 id : SV_DispatchThreadID)
{
    int li = (int)id.x;
    if (li >= _ActiveCount)
        return;

    int gi = _Base + li;

    int nCount, n0, n1, n2, n3, n4, n5;
    XPBI_GetNeighbors(gi, nCount, n0, n1, n2, n3, n4, n5);
    if (nCount <= 0)
    {
        _KernelH[gi] = 0.0;
        return;
    }

    float2 xi = _Pos[gi];

    float d[targetNeighborCount];
    int n = 0;

    int ns[targetNeighborCount];
    ns[0] = n0;
    ns[1] = n1;
    ns[2] = n2;
    ns[3] = n3;
    ns[4] = n4;
    ns[5] = n5;

    for (int k = 0; k < nCount; k++)
    {
        int gj = ns[k];
        if (gj < _Base || gj >= _Base + _ActiveCount)
            continue;

        float2 xij = _Pos[gj] - xi;
        float r = length(xij);
        if (r <= EPS)
            continue;

        d[n++] = r;
    }

    if (n == 0)
    {
        _KernelH[gi] = 0.0;
        return;
    }

    for (int a = 1; a < n; a++)
    {
        float key = d[a];
        int b = a - 1;
        while (b >= 0 && d[b] > key)
        {
            d[b + 1] = d[b];
            b--;
        }
        d[b + 1] = key;
    }

    float median;
    if ((n & 1) == 1)
    {
        median = d[n >> 1];
    }
    else
    {
        median = 0.5f * (d[(n >> 1) - 1] + d[n >> 1]);
    }
    _KernelH[gi] = median * KERNEL_H_SCALE;
}

[numthreads(256, 1, 1)] void ComputeCorrectionL(uint3 id : SV_DispatchThreadID)
{
    int li = (int)id.x;
    if (li >= _ActiveCount)
        return;

    int gi = _Base + li;

    float h = _KernelH[gi];
    if (h <= EPS)
    {
        _L[gi] = float4(0, 0, 0, 0);
        return;
    }

    int nCount, n0, n1, n2, n3, n4, n5;
    XPBI_GetNeighbors(gi, nCount, n0, n1, n2, n3, n4, n5);
    if (nCount <= 0)
    {
        _L[gi] = float4(0, 0, 0, 0);
        return;
    }

    float2 xi = _Pos[gi];

    XPBI_Mat2 sum = XPBI_Mat2Zero();
    int ns[targetNeighborCount];
    ns[0] = n0;
    ns[1] = n1;
    ns[2] = n2;
    ns[3] = n3;
    ns[4] = n4;
    ns[5] = n5;

    for (int k = 0; k < nCount; k++)
    {
        int gj = ns[k];
        if (gj < _Base || gj >= _Base + _ActiveCount)
            continue;

        float2 xij = _Pos[gj] - xi;

        float2 gradW = XPBI_GradWendlandC2(xij, h, EPS);
        if (dot(gradW, gradW) <= EPS * EPS)
            continue;

        float Vb = XPBI_ReadCurrentVolume(gj);
        if (Vb <= EPS)
            continue;

        sum.c0 += (Vb * xij.x) * gradW;
        sum.c1 += (Vb * xij.y) * gradW;
    }

    XPBI_Mat2 Lm = XPBI_PseudoInverseMat2(sum, STRETCH_EPS, EIGEN_OFFDIAG_EPS);
    _L[gi] = XPBI_Float4FromMat2(Lm);
}

    [numthreads(256, 1, 1)] void CacheF0AndResetLambda(uint3 id : SV_DispatchThreadID)
{
    int li = (int)id.x;
    if (li >= _ActiveCount)
        return;

    int gi = _Base + li;
    _F0[gi] = _F[gi];
    _Lambda[gi] = 0.0;
}

[numthreads(256, 1, 1)] void SaveVelPrefix(uint3 id : SV_DispatchThreadID)
{
    int li = (int)id.x;
    if (li >= _ActiveCount)
        return;

    int gi = _Base + li;
    _SavedVelPrefix[gi] = _Vel[gi];
}

    [numthreads(256, 1, 1)] void ClearVelDelta(uint3 id : SV_DispatchThreadID)
{
    int li = (int)id.x;
    if (li >= _ActiveCount)
        return;

    int gi = _Base + li;
    _VelDeltaBits[XPBI_VelDeltaIndex(gi, 0u)] = 0u;
    _VelDeltaBits[XPBI_VelDeltaIndex(gi, 1u)] = 0u;
}

static XPBI_Mat2 EstimateVelocityGradient(int gi, float2 xi, float2 vi, XPBI_Mat2 Lm, float h)
{
    XPBI_Mat2 gradV = XPBI_Mat2Zero();
    if (h <= EPS)
        return gradV;

    int nCount, n0, n1, n2, n3, n4, n5;
    XPBI_GetNeighbors(gi, nCount, n0, n1, n2, n3, n4, n5);
    if (nCount <= 0)
        return gradV;

    int ns[targetNeighborCount];
    ns[0] = n0;
    ns[1] = n1;
    ns[2] = n2;
    ns[3] = n3;
    ns[4] = n4;
    ns[5] = n5;

    for (int k = 0; k < nCount; k++)
    {
        int gj = ns[k];
        if (gj < _Base || gj >= _Base + _ActiveCount)
            continue;

        float2 xij = _Pos[gj] - xi;

        float2 gradW = XPBI_GradWendlandC2(xij, h, EPS);
        if (dot(gradW, gradW) <= EPS * EPS)
            continue;

        float Vb = XPBI_ReadCurrentVolume(gj);
        if (Vb <= EPS)
            continue;

        float2 correctedGrad = XPBI_MulMat2Vec(Lm, gradW);
        float2 dv = _Vel[gj] - vi;

        gradV.c0 += dv * (Vb * correctedGrad.x);
        gradV.c1 += dv * (Vb * correctedGrad.y);
    }

    return gradV;
}

[numthreads(256, 1, 1)] void RelaxScatter(uint3 id : SV_DispatchThreadID)
{
    int li = (int)id.x;
    if (li >= _ActiveCount)
        return;

    int gi = _Base + li;

    if (XPBI_IsFixed(gi))
        return;
    if (_RestVolume[gi] <= EPS)
        return;

    float h = _KernelH[gi];
    if (h <= EPS)
        return;

    int nCount, n0, n1, n2, n3, n4, n5;
    XPBI_GetNeighbors(gi, nCount, n0, n1, n2, n3, n4, n5);
    if (nCount <= 0)
        return;

    float2 xi = _Pos[gi];
    float2 vi = _Vel[gi];

    XPBI_Mat2 Lm = XPBI_Mat2FromFloat4(_L[gi]);
    XPBI_Mat2 gradV = EstimateVelocityGradient(gi, xi, vi, Lm, h);

    XPBI_Mat2 F0 = XPBI_Mat2FromFloat4(_F0[gi]);
    XPBI_Mat2 I = XPBI_Mat2Identity();

    XPBI_Mat2 dF = XPBI_Mat2FromCols(I.c0 + gradV.c0 * _Dt, I.c1 + gradV.c1 * _Dt);
    XPBI_Mat2 Ftrial = XPBI_MulMat2(dF, F0);
    XPBI_Mat2 Fel = XPBI_ApplyPlasticityReturn(Ftrial, YIELD_HENCKY, VOL_HENCKY_LIMIT, STRETCH_EPS, EIGEN_OFFDIAG_EPS, INV_DET_EPS);

    float C = XPBI_ConstraintC(Fel, MU, LAMBDA, STRETCH_EPS, EIGEN_OFFDIAG_EPS, INV_DET_EPS);
    if (abs(C) < EPS)
        return;

    XPBI_Mat2 dCdF = XPBI_ComputeGradient(Fel, MU, LAMBDA, STRETCH_EPS, EIGEN_OFFDIAG_EPS, INV_DET_EPS);
    XPBI_Mat2 FT = XPBI_TransposeMat2(Fel);

    float invDt = 1.0 / max(_Dt, EPS);
    float alphaTilde = (_Compliance / max(_RestVolume[gi], EPS)) * (invDt * invDt);

    float2 gradC_vi = float2(0, 0);
    float2 gradC_vj[targetNeighborCount];
    gradC_vj[0] = float2(0, 0);
    gradC_vj[1] = float2(0, 0);
    gradC_vj[2] = float2(0, 0);
    gradC_vj[3] = float2(0, 0);
    gradC_vj[4] = float2(0, 0);
    gradC_vj[5] = float2(0, 0);

    int ns[targetNeighborCount];
    ns[0] = n0;
    ns[1] = n1;
    ns[2] = n2;
    ns[3] = n3;
    ns[4] = n4;
    ns[5] = n5;

    for (int k = 0; k < nCount; k++)
    {
        int gj = ns[k];
        if (gj < _Base || gj >= _Base + _ActiveCount)
            continue;

        float2 xij = _Pos[gj] - xi;

        float2 gradW = XPBI_GradWendlandC2(xij, h, EPS);
        if (dot(gradW, gradW) <= EPS * EPS)
            continue;

        float Vb = XPBI_ReadCurrentVolume(gj);
        if (Vb <= EPS)
            continue;

        float2 correctedGrad = XPBI_MulMat2Vec(Lm, gradW);
        float2 t = XPBI_MulMat2Vec(FT, correctedGrad);
        float2 q = Vb * XPBI_MulMat2Vec(dCdF, t);

        gradC_vi -= q;
        gradC_vj[k] = q;
    }

    float denom = _InvMass[gi] * dot(gradC_vi, gradC_vi);
    for (int k1 = 0; k1 < nCount; k1++)
    {
        int gj = ns[k1];
        if (gj < _Base || gj >= _Base + _ActiveCount)
            continue;
        if (XPBI_IsFixed(gj))
            continue;
        denom += _InvMass[gj] * dot(gradC_vj[k1], gradC_vj[k1]);
    }

    if (denom < EPS)
        return;

    float lambdaBefore = _Lambda[gi];
    float dLambda = -(C + alphaTilde * lambdaBefore) / (denom + alphaTilde);
    if (isnan(dLambda) || isinf(dLambda))
        return;

    float velScale = dLambda * invDt;

    XPBI_AddVelDelta(gi, _InvMass[gi] * velScale * gradC_vi);

    for (int k2 = 0; k2 < nCount; k2++)
    {
        int gj = ns[k2];
        if (gj < _Base || gj >= _Base + _ActiveCount)
            continue;
        if (XPBI_IsFixed(gj))
            continue;
        XPBI_AddVelDelta(gj, _InvMass[gj] * velScale * gradC_vj[k2]);
    }

    _Lambda[gi] = lambdaBefore + dLambda;
}

    [numthreads(256, 1, 1)] void ApplyVelDelta(uint3 id : SV_DispatchThreadID)
{
    int li = (int)id.x;
    if (li >= _ActiveCount)
        return;

    int gi = _Base + li;

    float2 dv = XPBI_ReadVelDelta(gi);
    _Vel[gi] = _Vel[gi] + dv;

    _VelDeltaBits[XPBI_VelDeltaIndex(gi, 0u)] = 0u;
    _VelDeltaBits[XPBI_VelDeltaIndex(gi, 1u)] = 0u;
}

[numthreads(256, 1, 1)] void Prolongate(uint3 id : SV_DispatchThreadID)
{
    int li = (int)id.x;
    int childGi = _Base + (_ActiveCount + li);
    if (childGi >= _Base + _FineCount)
        return;

    int p = _ParentIndex[childGi];
    if (p < _Base || p >= _Base + _ActiveCount)
        return;

    float2 parentDeltaV = _Vel[p] - _SavedVelPrefix[p];
    _Vel[childGi] = _Vel[childGi] + parentDeltaV;
}

    [numthreads(256, 1, 1)] void CommitDeformation(uint3 id : SV_DispatchThreadID)
{
    int li = (int)id.x;
    if (li >= _ActiveCount)
        return;

    int gi = _Base + li;

    if (XPBI_IsFixed(gi))
        return;

    float h = _KernelH[gi];
    if (h <= EPS)
        return;

    float2 xi = _Pos[gi];
    float2 vi = _Vel[gi];

    XPBI_Mat2 Lm = XPBI_Mat2FromFloat4(_L[gi]);
    XPBI_Mat2 gradV = EstimateVelocityGradient(gi, xi, vi, Lm, h);

    XPBI_Mat2 F0 = XPBI_Mat2FromFloat4(_F0[gi]);
    XPBI_Mat2 I = XPBI_Mat2Identity();

    XPBI_Mat2 dF = XPBI_Mat2FromCols(I.c0 + gradV.c0 * _Dt, I.c1 + gradV.c1 * _Dt);
    XPBI_Mat2 Ftrial = XPBI_MulMat2(dF, F0);
    XPBI_Mat2 Fel = XPBI_ApplyPlasticityReturn(Ftrial, YIELD_HENCKY, VOL_HENCKY_LIMIT, STRETCH_EPS, EIGEN_OFFDIAG_EPS, INV_DET_EPS);

    XPBI_Mat2 FpOld = XPBI_Mat2FromFloat4(_Fp[gi]);

    float detFel = XPBI_DetMat2(Fel);
    if (abs(detFel) > EPS)
    {
        float invDet = 1.0 / detFel;

        XPBI_Mat2 FelInv;
        FelInv.c0 = float2(Fel.c1.y * invDet, -Fel.c0.y * invDet);
        FelInv.c1 = float2(-Fel.c1.x * invDet, Fel.c0.x * invDet);

        XPBI_Mat2 FpNew = XPBI_MulMat2(XPBI_MulMat2(FelInv, Ftrial), FpOld);
        _Fp[gi] = XPBI_Float4FromMat2(FpNew);
    }

    _F[gi] = XPBI_Float4FromMat2(Fel);
}

[numthreads(256, 1, 1)] void RelaxColored(uint3 id : SV_DispatchThreadID)
{
    int idx = (int)id.x;
    if (idx >= _ColorCount)
        return;

    int li = _ColorOrder[_ColorStart + idx];
    if (li < 0 || li >= _ActiveCount)
        return;

    int gi = _Base + li;

    if (XPBI_IsFixed(gi))
        return;
    if (_RestVolume[gi] <= EPS)
        return;

    float h = _KernelH[gi];
    if (h <= EPS)
        return;

    int nCount, n0, n1, n2, n3, n4, n5;
    XPBI_GetNeighbors(gi, nCount, n0, n1, n2, n3, n4, n5);
    if (nCount <= 0)
        return;

    float2 xi = _Pos[gi];
    float2 vi = _Vel[gi];

    XPBI_Mat2 Lm = XPBI_Mat2FromFloat4(_L[gi]);
    XPBI_Mat2 gradV = EstimateVelocityGradient(gi, xi, vi, Lm, h);

    XPBI_Mat2 F0m = XPBI_Mat2FromFloat4(_F0[gi]);
    XPBI_Mat2 I = XPBI_Mat2Identity();

    XPBI_Mat2 dF = XPBI_Mat2FromCols(I.c0 + gradV.c0 * _Dt, I.c1 + gradV.c1 * _Dt);
    XPBI_Mat2 Ftrial = XPBI_MulMat2(dF, F0m);
    XPBI_Mat2 Fel = XPBI_ApplyPlasticityReturn(Ftrial, YIELD_HENCKY, VOL_HENCKY_LIMIT, STRETCH_EPS, EIGEN_OFFDIAG_EPS, INV_DET_EPS);

    float C = XPBI_ConstraintC(Fel, MU, LAMBDA, STRETCH_EPS, EIGEN_OFFDIAG_EPS, INV_DET_EPS);
    if (abs(C) < EPS)
        return;

    XPBI_Mat2 dCdF = XPBI_ComputeGradient(Fel, MU, LAMBDA, STRETCH_EPS, EIGEN_OFFDIAG_EPS, INV_DET_EPS);
    XPBI_Mat2 FT = XPBI_TransposeMat2(Fel);

    float invDt = 1.0 / max(_Dt, EPS);
    float alphaTilde = (_Compliance / max(_RestVolume[gi], EPS)) * (invDt * invDt);

    float2 gradC_vi = float2(0, 0);
    float2 gradC_vj[targetNeighborCount];
    gradC_vj[0] = float2(0, 0);
    gradC_vj[1] = float2(0, 0);
    gradC_vj[2] = float2(0, 0);
    gradC_vj[3] = float2(0, 0);
    gradC_vj[4] = float2(0, 0);
    gradC_vj[5] = float2(0, 0);

    int ns[targetNeighborCount];
    ns[0] = n0;
    ns[1] = n1;
    ns[2] = n2;
    ns[3] = n3;
    ns[4] = n4;
    ns[5] = n5;

    for (int k = 0; k < nCount; k++)
    {
        int gj = ns[k];
        if (gj < _Base || gj >= _Base + _ActiveCount)
            continue;

        float2 xij = _Pos[gj] - xi;

        float2 gradW = XPBI_GradWendlandC2(xij, h, EPS);
        if (dot(gradW, gradW) <= EPS * EPS)
            continue;

        float Vb = XPBI_ReadCurrentVolume(gj);
        if (Vb <= EPS)
            continue;

        float2 correctedGrad = XPBI_MulMat2Vec(Lm, gradW);
        float2 t = XPBI_MulMat2Vec(FT, correctedGrad);
        float2 q = Vb * XPBI_MulMat2Vec(dCdF, t);

        gradC_vi -= q;
        gradC_vj[k] = q;
    }

    float denom = _InvMass[gi] * dot(gradC_vi, gradC_vi);
    for (int k1 = 0; k1 < nCount; k1++)
    {
        int gj = ns[k1];
        if (gj < _Base || gj >= _Base + _ActiveCount)
            continue;
        if (XPBI_IsFixed(gj))
            continue;
        denom += _InvMass[gj] * dot(gradC_vj[k1], gradC_vj[k1]);
    }
    if (denom < EPS)
        return;

    float lambdaBefore = _Lambda[gi];
    float dLambda = -(C + alphaTilde * lambdaBefore) / (denom + alphaTilde);
    if (isnan(dLambda) || isinf(dLambda))
        return;

    float velScale = dLambda * invDt;

    _Vel[gi] = _Vel[gi] + (_InvMass[gi] * velScale * gradC_vi);

    for (int k2 = 0; k2 < nCount; k2++)
    {
        int gj = ns[k2];
        if (gj < _Base || gj >= _Base + _ActiveCount)
            continue;
        if (XPBI_IsFixed(gj))
            continue;
        _Vel[gj] = _Vel[gj] + (_InvMass[gj] * velScale * gradC_vj[k2]);
    }

    _Lambda[gi] = lambdaBefore + dLambda;
}
